const n=JSON.parse('{"key":"v-131b2324","path":"/java/basic/common-class.html","title":"Java 常用类","lang":"zh-CN","frontmatter":{"title":"Java 常用类","category":"Java","tag":["Java 基础"],"description":"1. String、StringBuffer、StringBuilder （一）java.lang.String 类 特点 String 的不可变性 体现： ①给现有的字符串添加一个新的字符串，不能在原有的字符串后面添加，而必须声明一个新的内存空间，存放新的字符串； ②给现有的字符串重新赋值，不能在原有的常量池对应的字符串的位置赋值，必须重新声明一个新的内存空间，存放新的字符串； ③现有的字符串调用 replace() 方法，仍然声明一个新的内存空间，存放修改以后的字符串。 内存的存储结构 String 声明的变量，我们称为字符串，本质上数据存放在字符串常量池中，字符串常量池存放在方法区中。 jdk 6：方法区（具体的实现就是永久代---&gt;堆：新生代、老年代、永久代）； jdk 7：方法区取消，统一归入堆； jdk 8：元空间取代原的方法区 String 的实例化方式 方式一：通过字面量定义的方式； 方式二：通过new + 构造器的方式。 二者区别： ①字面量的方式：地址值对应的数据声明在方法区中的字符串常量池； ②new + 构造器的方式：地址值对应的数据声明在堆空间中（堆空间中对应的 String 对象里存的是对应声明在字符串常量池中的字符串（若有，则不用创建；若无，就创建）的地址值）。 // 方式一：通过字面量的方式 String s1 = \\"hello\\"; String s2 = \\"hello\\"; \\t\\t // 方式二：通过new + 构造器的方式 String s3 = new String(\\"hello\\"); String s4 = new String(\\"hello\\"); \\t\\t System.out.println(s1 == s2);// true System.out.println(s1 == s3);// false System.out.println(s3 == s4);// false image-20210811110223198","head":[["meta",{"property":"og:url","content":"http://www.hl1015.com/java/basic/common-class.html"}],["meta",{"property":"og:site_name","content":"程序员H"}],["meta",{"property":"og:title","content":"Java 常用类"}],["meta",{"property":"og:description","content":"1. String、StringBuffer、StringBuilder （一）java.lang.String 类 特点 String 的不可变性 体现： ①给现有的字符串添加一个新的字符串，不能在原有的字符串后面添加，而必须声明一个新的内存空间，存放新的字符串； ②给现有的字符串重新赋值，不能在原有的常量池对应的字符串的位置赋值，必须重新声明一个新的内存空间，存放新的字符串； ③现有的字符串调用 replace() 方法，仍然声明一个新的内存空间，存放修改以后的字符串。 内存的存储结构 String 声明的变量，我们称为字符串，本质上数据存放在字符串常量池中，字符串常量池存放在方法区中。 jdk 6：方法区（具体的实现就是永久代---&gt;堆：新生代、老年代、永久代）； jdk 7：方法区取消，统一归入堆； jdk 8：元空间取代原的方法区 String 的实例化方式 方式一：通过字面量定义的方式； 方式二：通过new + 构造器的方式。 二者区别： ①字面量的方式：地址值对应的数据声明在方法区中的字符串常量池； ②new + 构造器的方式：地址值对应的数据声明在堆空间中（堆空间中对应的 String 对象里存的是对应声明在字符串常量池中的字符串（若有，则不用创建；若无，就创建）的地址值）。 // 方式一：通过字面量的方式 String s1 = \\"hello\\"; String s2 = \\"hello\\"; \\t\\t // 方式二：通过new + 构造器的方式 String s3 = new String(\\"hello\\"); String s4 = new String(\\"hello\\"); \\t\\t System.out.println(s1 == s2);// true System.out.println(s1 == s3);// false System.out.println(s3 == s4);// false image-20210811110223198"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-05-17T09:01:25.000Z"}],["meta",{"property":"article:author","content":"程序员H"}],["meta",{"property":"article:tag","content":"Java 基础"}],["meta",{"property":"article:modified_time","content":"2023-05-17T09:01:25.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java 常用类\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-05-17T09:01:25.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"程序员H\\",\\"url\\":\\"http://www.hl1015.com/\\"}]}"]]},"headers":[{"level":2,"title":"1. String、StringBuffer、StringBuilder","slug":"_1-string、stringbuffer、stringbuilder","link":"#_1-string、stringbuffer、stringbuilder","children":[]},{"level":2,"title":"2. jdk8 之前的时间日期 API","slug":"_2-jdk8-之前的时间日期-api","link":"#_2-jdk8-之前的时间日期-api","children":[]},{"level":2,"title":"3. jdk8 中新时间日期 API","slug":"_3-jdk8-中新时间日期-api","link":"#_3-jdk8-中新时间日期-api","children":[]},{"level":2,"title":"4. jdk8 中的 Optional 类","slug":"_4-jdk8-中的-optional-类","link":"#_4-jdk8-中的-optional-类","children":[]},{"level":2,"title":"5. 其他类","slug":"_5-其他类","link":"#_5-其他类","children":[]}],"git":{"createdTime":1684314085000,"updatedTime":1684314085000,"contributors":[{"name":"hkw","email":"hkw1015@163.com","commits":1}]},"readingTime":{"minutes":11.89,"words":3566},"filePathRelative":"java/basic/common-class.md","localizedDate":"2023年5月17日","excerpt":"<h2> 1. String、StringBuffer、StringBuilder</h2>\\n<blockquote>\\n<p>（一）java.lang.String 类</p>\\n</blockquote>\\n<ul>\\n<li>\\n<p><strong>特点</strong></p>\\n<p>String 的不可变性</p>\\n<p>体现：</p>\\n<p>①给现有的字符串添加一个新的字符串，不能在原有的字符串后面添加，而必须声明一个新的内存空间，存放新的字符串；</p>\\n<p>②给现有的字符串重新赋值，不能在原有的常量池对应的字符串的位置赋值，必须重新声明一个新的内存空间，存放新的字符串；</p>\\n<p>③现有的字符串调用 replace() 方法，仍然声明一个新的内存空间，存放修改以后的字符串。</p>\\n</li>\\n<li>\\n<p><strong>内存的存储结构</strong></p>\\n<p>String 声明的变量，我们称为字符串，本质上数据存放在字符串常量池中，字符串常量池存放在方法区中。</p>\\n<blockquote>\\n<p>jdk 6：方法区（具体的实现就是永久代---&gt;堆：新生代、老年代、永久代）；</p>\\n<p>jdk 7：方法区取消，统一归入堆；</p>\\n<p>jdk 8：元空间取代原的方法区</p>\\n</blockquote>\\n</li>\\n<li>\\n<p><strong>String 的实例化方式</strong></p>\\n<p>方式一：通过字面量定义的方式；</p>\\n<p>方式二：通过new + 构造器的方式。</p>\\n<p>二者区别：</p>\\n<p>①字面量的方式：地址值对应的数据声明在方法区中的字符串常量池；</p>\\n<p>②new + 构造器的方式：地址值对应的数据声明在堆空间中（堆空间中对应的 String 对象里存的是对应声明在字符串常量池中的字符串（若有，则不用创建；若无，就创建）的地址值）。</p>\\n<div class=\\"language-java line-numbers-mode\\" data-ext=\\"java\\"><pre class=\\"language-java\\"><code><span class=\\"token comment\\">// 方式一：通过字面量的方式</span>\\n<span class=\\"token class-name\\">String</span> s1 <span class=\\"token operator\\">=</span> <span class=\\"token string\\">\\"hello\\"</span><span class=\\"token punctuation\\">;</span>\\n<span class=\\"token class-name\\">String</span> s2 <span class=\\"token operator\\">=</span> <span class=\\"token string\\">\\"hello\\"</span><span class=\\"token punctuation\\">;</span>\\n\\t\\t\\n<span class=\\"token comment\\">// 方式二：通过new + 构造器的方式</span>\\n<span class=\\"token class-name\\">String</span> s3 <span class=\\"token operator\\">=</span> <span class=\\"token keyword\\">new</span> <span class=\\"token class-name\\">String</span><span class=\\"token punctuation\\">(</span><span class=\\"token string\\">\\"hello\\"</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n<span class=\\"token class-name\\">String</span> s4 <span class=\\"token operator\\">=</span> <span class=\\"token keyword\\">new</span> <span class=\\"token class-name\\">String</span><span class=\\"token punctuation\\">(</span><span class=\\"token string\\">\\"hello\\"</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n\\t\\t\\n<span class=\\"token class-name\\">System</span><span class=\\"token punctuation\\">.</span>out<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">println</span><span class=\\"token punctuation\\">(</span>s1 <span class=\\"token operator\\">==</span> s2<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span><span class=\\"token comment\\">// true</span>\\n<span class=\\"token class-name\\">System</span><span class=\\"token punctuation\\">.</span>out<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">println</span><span class=\\"token punctuation\\">(</span>s1 <span class=\\"token operator\\">==</span> s3<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span><span class=\\"token comment\\">// false</span>\\n<span class=\\"token class-name\\">System</span><span class=\\"token punctuation\\">.</span>out<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">println</span><span class=\\"token punctuation\\">(</span>s3 <span class=\\"token operator\\">==</span> s4<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span><span class=\\"token comment\\">// false</span>\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div><figure><img src=\\"https://pet-hkw.oss-cn-shenzhen.aliyuncs.com/image/new_blog_system/java/base/image-20210811110223198.png\\" alt=\\"image-20210811110223198\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>image-20210811110223198</figcaption></figure>\\n</li>\\n</ul>","autoDesc":true}');export{n as data};
