import{_ as a,Z as s,$ as e,a5 as n}from"./framework-1fb77053.js";const t={},r=n(`<h2 id="_1-事务的概念和特性" tabindex="-1"><a class="header-anchor" href="#_1-事务的概念和特性" aria-hidden="true">#</a> 1. 事务的概念和特性</h2><h3 id="_1-1-事务的概念" tabindex="-1"><a class="header-anchor" href="#_1-1-事务的概念" aria-hidden="true">#</a> 1.1 事务的概念</h3><p><strong><span style="color:red;">事务由单独单元的一个或多个 SQL 语句组成，在这个单元中，每个 MySQL 语句是相互依赖的</span></strong>。而整个单独单元作为一个不可分割的整体，如果单元中的某条 SQL 语句一旦执行失败或产生错误，整个单元将会回滚。所有受到影响的数据将返回到事务开始以前的状态；如果单元中的所有 SQL 语句均执行成功，则事务被顺利执行。</p><h3 id="_1-2-mysql-中的存储引擎【了解】" tabindex="-1"><a class="header-anchor" href="#_1-2-mysql-中的存储引擎【了解】" aria-hidden="true">#</a> 1.2 MySQL 中的存储引擎【了解】</h3><p>（1）概念：在 MySQL 中的数据用各种不同的技术存储在文件（或内存）中</p><p>（2）通过 <strong>SHOW ENGINES;</strong> 来查看 MySQL 支持的存储引擎</p><p>（3）在 MySQL 中用的最多的存储引擎有：innodb，myisam，memory 等，其中 innodb 支持事务，而 myisam，memory 等不支持事务</p><h3 id="_1-3-事务的特点" tabindex="-1"><a class="header-anchor" href="#_1-3-事务的特点" aria-hidden="true">#</a> 1.3 事务的特点</h3><p><strong>事务的 ACID(acid) 属性</strong></p><p><strong>（1）原子性（Atomicity）</strong></p><p>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生</p><p><strong>（2）一致性（Consistency）</strong></p><p>事务必须使数据库从一个一致性状态变换到另外一个一致性状态</p><p><strong>（3）隔离性（Isolation）</strong></p><p>事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰</p><p><strong>（4）持久性（Durability）</strong></p><p>持久性是指一个事务一旦被提交，它对数据库中的数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响</p><h3 id="_1-4-事务的使用" tabindex="-1"><a class="header-anchor" href="#_1-4-事务的使用" aria-hidden="true">#</a> 1.4 事务的使用</h3><ul><li><p>以第一个 DML 语句的执行作为开始</p></li><li><p>以下面的其中之一作为结束</p><ul><li>COMMIT 或 ROLLBACK 语句</li><li>DDL 或 DCL 语句（自动提交）</li><li>用户会话正常结束</li><li>系统异常终止</li></ul></li></ul><h2 id="_2-事务的隔离级别" tabindex="-1"><a class="header-anchor" href="#_2-事务的隔离级别" aria-hidden="true">#</a> 2. 事务的隔离级别</h2><h3 id="_2-1-说明" tabindex="-1"><a class="header-anchor" href="#_2-1-说明" aria-hidden="true">#</a> 2.1 说明</h3><p>（1）对于同时运行的多个事务，当这些事物访问数据库中相同的数据时，如果没有采取必要的隔离机制，就会导致各种并发问题：</p><ul><li><strong>脏读</strong>：对于两个事务 T1，T2，T1 已经读取了已经被 T2 更新但还<strong>没有被提交</strong>的字段，之后，若 T2 回滚，T1 读取的内容就是临时且无效的</li><li><strong>不可重复读</strong>：对于两个事务 T1，T2，T1 读取了一个字段，然后 T2 <strong>更新</strong>了该字段，之后，T1 再次读取同一个字段，值就不同了</li><li><strong>幻读</strong>：对于两个事务 T1，T2，T1 从一个表中读取了一个字段，然后 T2 在该表中<strong>插入</strong>了一些新的行，之后，如果 T1 再次读取同一个表，就会多出几行</li></ul><p>（2）数据库的隔离性：数据库系统必须具有隔离并发运行各个事务的能力，使它们不会相互影响，避免各种并发问题</p><p>（3）一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据库一致性就越好，但并发性越弱</p><h3 id="_2-2-数据库的隔离级别" tabindex="-1"><a class="header-anchor" href="#_2-2-数据库的隔离级别" aria-hidden="true">#</a> 2.2 数据库的隔离级别</h3><p>（1）数据库提供了 4 种事务隔离级别</p><table><thead><tr><th style="text-align:center;">隔离级别</th><th style="text-align:center;">描述</th></tr></thead><tbody><tr><td style="text-align:center;">READ UNCOMMITED（读未提交）</td><td style="text-align:center;">允许事务读取未被其他事务提交的变更，脏读、不可重复读和幻读的问题都会出现</td></tr><tr><td style="text-align:center;">READ COMMIT（读已提交）</td><td style="text-align:center;">只允许事务读取已经被其他事务提交的变更，可以避免脏读，但不可重复读和幻读问题仍然可能出现</td></tr><tr><td style="text-align:center;">REPEATABLE READ（可重复读）</td><td style="text-align:center;">确保事务可以多次从一个字段中读取到相同的值，在这个事务持续期间，禁止其他事务对这个字段进行更新，可以避免脏读和不可重复读，但幻读的问题仍然存在</td></tr><tr><td style="text-align:center;">SERIALIZABLE（串行化）</td><td style="text-align:center;">确保事务可以从一个表中读取相同的行，在这个事务持续期间，禁止其他事务对该表进行插入、更新和删除操作，所有并发问题都可以避免，但性能十分低下</td></tr></tbody></table><p>（2）Oracle 支持的 2 种事务隔离级别：READ COMMITED、SERIALIZABLE。Oracle 默认的事务隔离级别为：<strong>READ COMMITED</strong></p><p>（3）MySQL 支持 4 种事务隔离级别，默认的事务隔离级别为：<strong>REPEATABLE READ</strong></p><h3 id="_2-3-在-mysql-中设置隔离级别" tabindex="-1"><a class="header-anchor" href="#_2-3-在-mysql-中设置隔离级别" aria-hidden="true">#</a> 2.3 在 MySQL 中设置隔离级别</h3><p>（1）每启动一个 MySQL 程序，就会获得一个单独的数据库连接，每个数据库连接都有一个全局变量**@@tx_isolation**，表示当前的事务隔离级别</p><p>（2）查看当前的隔离级别：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> @<span class="token variable">@tx_isolation</span><span class="token punctuation">(</span>旧版<span class="token punctuation">)</span>

<span class="token keyword">SELECT</span> @<span class="token variable">@transaction_isolation</span><span class="token punctuation">(</span>新版<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（3）设置当前 MySQL 连接的隔离级别</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">set</span> <span class="token keyword">transaction</span> <span class="token keyword">isolation</span> <span class="token keyword">level</span> <span class="token keyword">read</span> commited<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>（4）设置数据库系统的<strong>全局</strong>隔离级别</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">set</span> <span class="token keyword">global</span> <span class="token keyword">transaction</span> <span class="token keyword">isolation</span> <span class="token keyword">level</span> <span class="token keyword">read</span> commited<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,38),l=[r];function i(d,o){return s(),e("div",null,l)}const c=a(t,[["render",i],["__file","mysql-basic-10.html.vue"]]);export{c as default};
