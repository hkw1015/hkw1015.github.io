import{_ as n,Z as s,$ as a,a5 as p}from"./framework-1fb77053.js";const t={},e=p(`<h2 id="_1-关键词-static" tabindex="-1"><a class="header-anchor" href="#_1-关键词-static" aria-hidden="true">#</a> 1. 关键词：static</h2><ul><li><p><strong>可以用来修饰的结构</strong></p><p>属性、方法、代码块、内部类</p></li><li><p><strong>static 修饰属性：静态变量（或类变量）</strong></p><p>①将属性按照是否使用 static 修饰，分为类变量和实例变量</p><p>​      类变量：类创建的多个对象共用同一套类变量；</p><p>​      实例变量：类创建的每个对象各自拥有一套实例变量。</p><p>②类的某一个对象可以调用类变量，其对类变量的修改，会导致其他对象调用此类变量时，是修改过了的，而类的某一个对象修改了实例变量，不会影响其他对象同名的实例变量的值；</p><p>③类变量，随着类的加载而加载，实例变量，随着对象的创建而加载；</p><p>④内存中，实例变量存储在堆空间中，类变量存储在静态域中，而静态域存储在方法区。</p></li><li><p><strong>static修饰方法</strong></p><p>①随着类的加载而加载；</p><p>②在静态方法内部：能调用静态的属性或静态的方法，不能调用非静态的属性或非静态的方法；</p><p>在非静态方法内部：能调用静态的属性或静态的方法，也能调用非静态的属性或非静态的方法；</p></li><li><p><strong>如何使用static关键字？</strong></p><p>（1）什么样的属性适合声明为 static？</p><p>​      ①类的多个对象要共享此唯一的数据；</p><p>​      ②类中的常量。</p><p>（2）什么样的方法适合声明为 static？</p><p>​      ①工具类中的方法（比如：Arrays工具类）；</p><p>​      ②操作静态变量的方法，通常为静态的。</p></li><li><p><strong>举例</strong></p><p>单例模式、工具类：Arrays / Math / Collections / XxxUtils / XxxFactory</p></li></ul><h2 id="_2-单例模式" tabindex="-1"><a class="header-anchor" href="#_2-单例模式" aria-hidden="true">#</a> 2. 单例模式</h2><ul><li><p><strong>设计模式的说明</strong></p><p>（1）设计模式是在大量的实践中总结和理论优化之后的代码结构、编程风格以及解决问题的思考方式；</p><p>（2）总结出了一共23种经典的设计模式。</p></li><li><p><strong>单例模式</strong></p><p>（1）要解决的问题</p><p>​      保证在整个软件系统中，对某个类只能存在一个对象实例。</p><p>（2）实现方式的对比</p><p>​      实现方式有：饿汉式 和 懒汉式；</p><p>​      饿汉式：线程安全的创建方式；</p><p>​      懒汉式：延迟对象的加载，节省内存空间，是线程不安全的创建方式。</p><p>（3）具体代码的实现</p></li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 饿汉式1</span>
<span class="token keyword">class</span> <span class="token class-name">Singleton1</span> <span class="token punctuation">{</span>
	<span class="token comment">// 1.私有化构造器</span>
	<span class="token keyword">private</span> <span class="token class-name">Singleton1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		
	<span class="token punctuation">}</span>
	
	<span class="token comment">// 2.内部创建当前类的实例，使用private static修饰</span>
	<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton1</span> singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">// 3.通过get()方法返回当前类的实例，使用public static修饰</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton1</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> singleton<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 饿汉式2</span>
<span class="token keyword">class</span> <span class="token class-name">Singleton2</span> <span class="token punctuation">{</span>
	<span class="token keyword">private</span> <span class="token class-name">Singleton2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		
	<span class="token punctuation">}</span>
	
	<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton2</span> singleton <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	
	<span class="token comment">// 代码块里进行实例化</span>
	<span class="token punctuation">{</span>
		singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton2</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> singleton<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 懒汉式</span>
<span class="token keyword">class</span> <span class="token class-name">Singleton3</span> <span class="token punctuation">{</span>
	<span class="token keyword">private</span> <span class="token class-name">Singleton3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		
	<span class="token punctuation">}</span>
	
	<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton3</span> singleton<span class="token punctuation">;</span>
	
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton3</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> singleton<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3-main-的使用说明" tabindex="-1"><a class="header-anchor" href="#_3-main-的使用说明" aria-hidden="true">#</a> 3. main()的使用说明</h2><p>（1）main() 作为程序的入口；</p><p>（2）作为一个类的普通的静态方法；</p><p>（3）mian() 可以作为用户与程序交互的一种方式（类似于Scanner）。</p><p>传入参数值：java 类名 参数值1 参数值2 参数值3 ...</p><p>注意：此时传入的参数值都是 String 类型。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 方法体；</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>1.权限修饰符：private &lt; 缺省 &lt; protected &lt; public</p><p>2.修饰方法的特殊关键字：static final abstract</p><p>3.方法的返回值类型：void / 具体的数据类型 （方法体中一定会有return)</p><p>4.方法名：需要满足标识符的命名规则和规范；见名知意</p><p>5.形参列表：方法的重载；可变个数形参的方法；参数传递机制；多态性</p><p>6.方法体：体现方法的具体功能</p></blockquote><h2 id="_4-类的结构之四-代码块" tabindex="-1"><a class="header-anchor" href="#_4-类的结构之四-代码块" aria-hidden="true">#</a> 4. 类的结构之四：代码块</h2><blockquote><p>代码块（初始化块）：类的第四个成员（重要性较属性、方法、构造器差一些）</p></blockquote><ul><li><p><strong>代码块的作用</strong></p><p>用来初始化类或对象的信息</p></li><li><p><strong>分类</strong></p><p>静态代码块 和 非静态代码块</p></li><li><p><strong>静态代码块</strong></p><p>（1）可以输出语句；</p><p>（2）随着类的加载而加载，只执行一次；</p><p>（3）作用：用来初始化类的信息；</p><p>（4）静态代码块内部只能调用当前类的静态的属性或方法，不能调用非静态的结构；</p><p>（5）静态代码块的执行要早于非静态代码块；</p><p>（6）多个静态代码块之间，是按照声明的先后顺序执行的。</p></li><li><p><strong>非静态代码块</strong></p><p>（1）可以输出语句；</p><p>（2）随着对象的创建而执行，每创建一个对象，就执行一次；</p><p>（3）作用：用来初始化对象的信息；</p><p>（4）非静态代码块内部能调用当前类的静态的属性或方法，也能调用非静态的属性或方法。</p><p>（5）多个非静态代码块之间，是按照声明的先后顺序执行的。</p></li><li><p><strong>属性赋值顺序</strong></p><p>①默认初始化；</p><p>②显示初始化/在代码块中给属性初始化；</p><p>③构造器初始化；</p><p>④有了对象以后，通过“对象.属性”或“对象.方法”的方式，给属性赋值。</p><p>说明：赋值的先后顺序：①-②-③-④，其中步骤①②③只执行一次。</p></li></ul><h2 id="_5-关键字-final" tabindex="-1"><a class="header-anchor" href="#_5-关键字-final" aria-hidden="true">#</a> 5. 关键字：final</h2><blockquote><p>final：最终的</p></blockquote><ul><li><p><strong>可以用来修饰的结构</strong></p><p>类、变量、方法</p></li><li><p><strong>具体使用说明</strong></p><p>（1）final 修饰类：表明该类不可被继承。比如：String 类；</p><p>（2）final 修饰变量：表明此变量的值不能再被改变，即此变量实际上是一个常量。</p><p>​      final 修饰成员变量：此变量是一个常量。可以考虑赋值的方式有：</p><p>​            ①显示赋值；②代码块中赋值；③构造器中赋值。</p><p>（3）final 修饰方法：表明此方法不能被重写。比如：Object 类中的 getClass()；</p></li></ul><h2 id="_6-关键字-abstract" tabindex="-1"><a class="header-anchor" href="#_6-关键字-abstract" aria-hidden="true">#</a> 6. 关键字：abstract</h2><blockquote><p>abstract：抽象的</p></blockquote><ul><li><p><strong>可以用来修饰的结构</strong></p><p>类、方法</p></li><li><p><strong>具体使用说明</strong></p><p>（1）abstract 修饰类：抽象类</p><p>​      ①抽象类是不可以被实例化的；</p><p>​      ②实际开发中，我们都会去提供抽象类的子类，由子类实例化，使用父类中声明的结构；</p><p>​      ③抽象类中一定存在构造器。构造器的作用：方便子类对象实例化时调用；</p><p>​      ④抽象方法所在的类一定是抽象类，反之，抽象类中可以没有声明抽象方法。</p><p>（2）abstract 修饰方法：抽象方法</p><p>​      ①子类继承抽象的父类以后，如果重写了所有的抽象方法，则此子类就不是一个抽象类，就可以实例化；</p><p>​      ②子类继承抽象的父类以后，如果没重写完所有的抽象方法，则此子类仍是一个抽象类，不可以实例化。</p></li><li><p><strong>注意点</strong></p><p>①抽象性依赖于继承性；</p><p>②不能用来修饰属性、构造器等结构；</p><p>③不和能 private / final / static 共用。</p></li><li><p><strong>abstract 的应用实例</strong></p><p>举例一：抽象类 GeometricObject (提供抽象方法：findArea())及其子类Circle 、MyRetangle。</p><p>举例二：InputStream 抽象类及其内部的抽象方法：read()。</p></li></ul><h2 id="_7-关键字-interface" tabindex="-1"><a class="header-anchor" href="#_7-关键字-interface" aria-hidden="true">#</a> 7. 关键字：interface</h2><blockquote><p>interface：接口</p></blockquote><ul><li><p><strong>使用说明</strong></p><p>（1）类与接口是并列的两个结构；</p><p>（2）接口使用interface关键字定义；</p><p>（3）接口中可以声明的结构：属性、方法；</p><p>​      ①接口中不能声明构造器！意味着接口不能实例化；</p><p>​      ②属性：接口中定义的属性都声明为：public static final的（默认有，可以省略）。</p><p>​      ③方法：jdk7 以及以前版本，接口中定义的方法都是抽象方法，声明为：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">abstract</span>（默认有，可以省略）。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>​      jdk8 开始，接口中除了定义抽象方法之外，还可以定义静态方法、默认方法。</p><p>（4）接口，实际上可以看成是一种标准、一种规范；</p><p>（5）java 类和接口之间是实现（implements）关系，而且是可以多实现的。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>格式：
<span class="token keyword">class</span> <span class="token class-name">SubClass</span> <span class="token keyword">extends</span> <span class="token class-name">SuperClass</span> <span class="token keyword">implements</span> 接口<span class="token number">1</span>，接口<span class="token number">2</span>，接口<span class="token number">3</span>，<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>​      如果 java 类实现了某个或某几个接口，则需要重写接口中的所有抽象方法，方可实例化；</p><p>​      如果 java 类实现了某个或某几个接口，没重写接口中所有的抽象方法，则此类必须声明为抽象类。</p><p>（6）接口与接口之间是继承关系，而且可以多继承；</p><p>（7）接口与实现类之间的多态性。</p></li><li><p><strong>体会面向接口编程的思想</strong></p></li></ul><figure><img src="https://pet-hkw.oss-cn-shenzhen.aliyuncs.com/image/new_blog_system/java/base/image-20210810111155422.png" alt="image-20210810111155422" tabindex="0" loading="lazy"><figcaption>image-20210810111155422</figcaption></figure><p>jdbc 当中规定了很多的接口，用于规范 java 应用程序如何操作具体的数据库。</p><p>对于程序员来讲，只需要面向这套接口编程即可。</p><ul><li><p><strong>java8 中针对接口的新特性</strong></p><p>（1）jdk8 中可以额外定义静态方法和默认方法。</p><p>（2）具体的使用：</p><p>​     知识点1：接口中的静态方法，不能被实现类直接调用，只能通过接口自己来调用</p><p>​     知识点2：可以通过实现类的对象调用接口中声明的默认方法</p><p>​     知识点3：如果父类和接口中声明了同名同参数的方法，则子类继承父类，实现接口以后，在没重写此方法的情况下，默认调用的父类中的方法。---&quot;类优先&quot;原则</p><p>​     知识点4：接口冲突：实现类实现了两个接口，而两个接口中定义了同名同参数的方法，则实现类默认情况下就报错。</p><p>​          要求：实现类必须要重写同名同参数的方法。</p><p>​     知识点5：通过“接口.super.方法”的方式调用实现的接口中的被重写的方法</p></li></ul><h2 id="_8-类的结构之五-内部类" tabindex="-1"><a class="header-anchor" href="#_8-类的结构之五-内部类" aria-hidden="true">#</a> 8. 类的结构之五：内部类</h2><blockquote><p>内部类：类的第五个成员</p></blockquote><ul><li><p><strong>定义</strong></p><p>我们可以在一个类A的内部，声明另一个类B，此时，类A：外部类，类B：内部类。</p></li><li><p><strong>内部类的分类</strong></p><p>成员内部类（静态的 vs 非静态的） vs 局部内部类</p></li><li><p><strong>说明</strong></p><p>一方面，作为类：</p><p>    ①内部可以声明属性、方法、构造器；</p><p>    ②可以被 abstract 修饰；</p><p>    ③可以被 final 修饰。</p><p>另一方面，作为外部类的成员：</p><p>    ①可以被4种权限修饰符修饰；</p><p>    ②可以调用外部的属性、方法等结构；</p><p>    ③可以被 static 修饰。</p></li><li><p><strong>成员内部类</strong></p><p>（1）如何创建成员内部类的对象？（静态的、非静态的）</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 如何创建静态的成员内部类对象</span>
<span class="token class-name">Person<span class="token punctuation">.</span>Dog</span> dog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person<span class="token punctuation">.</span>Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 错误的：Person.new Dog()</span>
dog<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 如何创建非静态的成员内部类对象</span>
<span class="token comment">// Person.Bird bird = new Person.Bird();//错误的</span>
<span class="token class-name">Person</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Person<span class="token punctuation">.</span>Bird</span> bird <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Bird</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 错误的：new p.Bird();</span>
bird<span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token string">&quot;麻雀&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（2）如何在成员内部类中调用外部类的结构？</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>
	<span class="token class-name">String</span> name<span class="token punctuation">;</span>

	<span class="token keyword">class</span> <span class="token class-name">Bird</span><span class="token punctuation">{</span>
		<span class="token class-name">String</span> name<span class="token punctuation">;</span>

		<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 形参</span>
			<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Bird 的属性</span>
			<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Person 的属性</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>局部内部类</strong></p></li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 此情况开发中很少见</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	
	<span class="token comment">// 局部内部类</span>
	<span class="token keyword">class</span> <span class="token class-name">InnerClass</span><span class="token punctuation">{</span>
		
	<span class="token punctuation">}</span>
	
<span class="token punctuation">}</span>

<span class="token comment">// 较为常见的</span>
<span class="token comment">// 返回一个实现了 Comparable 的类的对象</span>
<span class="token keyword">public</span> <span class="token class-name">Comparable</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	
	<span class="token comment">// 写法一：提供实现了接口的内部类</span>
<span class="token comment">//		class MyComparable implements Comparable{</span>
<span class="token comment">//</span>
<span class="token comment">//			@Override</span>
<span class="token comment">//			public int compareTo(Object o) {</span>
<span class="token comment">//				return 0;</span>
<span class="token comment">//			}</span>
<span class="token comment">//			</span>
<span class="token comment">//		}</span>
<span class="token comment">//		</span>
<span class="token comment">//		</span>
<span class="token comment">//		return  new MyComparable();</span>
	
	<span class="token comment">// 写法二：返回接口的匿名实现类的匿名对象</span>
	<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Comparable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>

		<span class="token annotation punctuation">@Override</span>
		<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,33),l=[e];function i(c,o){return s(),a("div",null,l)}const r=n(t,[["render",i],["__file","object-oriented-3.html.vue"]]);export{r as default};
