import{_ as d,E as l,Z as c,$ as r,a0 as e,a1 as a,a3 as n,a4 as s,a5 as o}from"./framework-1fb77053.js";const g={},u=o(`<h2 id="_1-帮助启动类命令" tabindex="-1"><a class="header-anchor" href="#_1-帮助启动类命令" aria-hidden="true">#</a> 1. 帮助启动类命令</h2><ul><li><strong>启动 Docker</strong>：<strong><code>systemctl start docker</code></strong></li><li><strong>停止 Docker</strong>：<strong><code>systemctl stop docker</code></strong></li><li><strong>重启 Docker</strong>：<strong><code>systemctl restart docker</code></strong></li><li><strong>查看 docker 状态</strong>：<strong><code>systemctl status docker</code></strong></li><li><strong>开机启动</strong>：<strong><code>systemctl enable docker</code></strong></li><li><strong>查看 docker 概要信息</strong>：<strong><code>docker info</code></strong></li><li><strong>查看 docker 总体帮助文档</strong>：<strong><code>docker --help</code></strong></li><li><strong>查看 docker 命令帮助文档</strong>：<strong><code>docker 具体命令 --help</code></strong></li></ul><h2 id="_2-镜像命令" tabindex="-1"><a class="header-anchor" href="#_2-镜像命令" aria-hidden="true">#</a> 2. 镜像命令</h2><h3 id="_2-1-列出本地镜像" tabindex="-1"><a class="header-anchor" href="#_2-1-列出本地镜像" aria-hidden="true">#</a> 2.1 列出本地镜像</h3><ul><li>命令</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> images <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>演示</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@centos101 ~<span class="token punctuation">]</span><span class="token comment"># docker images</span>
REPOSITORY    TAG       IMAGE ID       CREATED        SIZE
hello-world   latest    feb5d9fea6a5   <span class="token number">5</span> months ago   <span class="token number">13</span>.3kB
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>参数说明 <ul><li><strong><code>REPOSITORY</code>：表示镜像的仓库源</strong></li><li><strong><code>TAG</code>：镜像的标签版本号</strong></li><li><strong><code>IMAGE ID</code>：镜像 ID</strong></li><li><strong><code>CREATED</code>：镜像创建时间</strong></li><li><strong><code>SIZE</code>：镜像大小</strong></li></ul></li></ul><blockquote><p>同一仓库源可以有多个 TAG 版本，代表这个仓库源的不同版本，我们使用 <code>REPOSITORY:TAG</code> 来定义不同的镜像，如果不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 <code>ubuntu:lastest</code> 镜像</p></blockquote><ul><li>OPTIONS 说明 <ul><li>-a：列出本地所有的镜像（含历史映像层）</li><li>-q：只显示镜像 ID</li></ul></li></ul><h3 id="_2-2-从-docker-hub-查找镜像" tabindex="-1"><a class="header-anchor" href="#_2-2-从-docker-hub-查找镜像" aria-hidden="true">#</a> 2.2 从 Docker Hub 查找镜像</h3>`,12),p={href:"https://hub.docker.com",target:"_blank",rel:"noopener noreferrer"},h=o(`<ul><li>命令</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> search <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> 镜像名字
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>演示</li></ul><figure><img src="http://img.hl1015.top/blog/image-20220305112317600.png" alt="image-20220305112317600" tabindex="0" loading="lazy"><figcaption>image-20220305112317600</figcaption></figure><ul><li><p>OPTIONS 说明</p><ul><li>--limit：只列出 N 个镜像，默认 25 个【例：<code>docker search --limit 5 redis</code>】</li></ul></li><li><p>参数说明</p><ul><li><strong><code>NAME</code>：镜像仓库源的名称</strong></li><li><strong><code>DESCRIPTION</code>：镜像的描述</strong></li><li><strong><code>OFFICIAL</code>：是否是 Docker 官方发布</strong></li><li><strong><code>STARS</code>：类似 GitHub 里面的 star，表示点赞、喜欢的意思</strong></li><li><strong><code>AUTOMATED</code>：自动构建</strong></li></ul></li></ul><h3 id="_2-3-从镜像仓库中拉取或者更新指定镜像" tabindex="-1"><a class="header-anchor" href="#_2-3-从镜像仓库中拉取或者更新指定镜像" aria-hidden="true">#</a> 2.3 从镜像仓库中拉取或者更新指定镜像</h3><ul><li>命令</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> pull 镜像名字<span class="token punctuation">[</span>:TAG<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>演示</li></ul><figure><img src="http://img.hl1015.top/blog/image-20220307214641863.png" alt="image-20220307214641863" tabindex="0" loading="lazy"><figcaption>image-20220307214641863</figcaption></figure><blockquote><p>没有 TAG 就是最新版，等价于 <code>docker pull ubuntu:lastest</code></p></blockquote><h3 id="_2-4-查看镜像-容器-数据卷所占的空间" tabindex="-1"><a class="header-anchor" href="#_2-4-查看镜像-容器-数据卷所占的空间" aria-hidden="true">#</a> 2.4 查看镜像/容器/数据卷所占的空间</h3><ul><li>命令</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> system <span class="token function">df</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>演示</li></ul><figure><img src="http://img.hl1015.top/blog/image-20220307215152236.png" alt="image-20220307215152236" tabindex="0" loading="lazy"><figcaption>image-20220307215152236</figcaption></figure><h3 id="_2-5-删除本地一个或多个镜像" tabindex="-1"><a class="header-anchor" href="#_2-5-删除本地一个或多个镜像" aria-hidden="true">#</a> 2.5 删除本地一个或多个镜像</h3>`,17),m=o(`<p>命令</p><ul><li>删除单个</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> rmi <span class="token parameter variable">-f</span> 镜像ID
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>删除多个</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> rmi <span class="token parameter variable">-f</span> 镜像名1:TAG 镜像名2:TAG
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,5),b=o('<div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> rmi <span class="token parameter variable">-f</span> <span class="token variable">${docker images -qa}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>',1),f=e("li",null,[e("p",null,"演示")],-1),v=o('<figure><img src="http://img.hl1015.top/blog/image-20220307220043876.png" alt="image-20220307220043876" tabindex="0" loading="lazy"><figcaption>image-20220307220043876</figcaption></figure><h3 id="_2-6-什么是-docker-虚悬镜像" tabindex="-1"><a class="header-anchor" href="#_2-6-什么是-docker-虚悬镜像" aria-hidden="true">#</a> 2.6 什么是 Docker 虚悬镜像？</h3><p>仓库名、标签是 &lt;none&gt; 的镜像，俗称虚悬镜像（dangling image）</p><figure><img src="http://img.hl1015.top/blog/image-20220307220357582.png" alt="image-20220307220357582" tabindex="0" loading="lazy"><figcaption>image-20220307220357582</figcaption></figure><h2 id="_3-容器命令" tabindex="-1"><a class="header-anchor" href="#_3-容器命令" aria-hidden="true">#</a> 3. 容器命令</h2><blockquote><p>下载一个 ubuntu 镜像到本地来进行演示</p><figure><img src="http://img.hl1015.top/blog/image-20220309103059908.png" alt="image-20220309103059908" tabindex="0" loading="lazy"><figcaption>image-20220309103059908</figcaption></figure></blockquote><h3 id="_3-1-新建-启动容器" tabindex="-1"><a class="header-anchor" href="#_3-1-新建-启动容器" aria-hidden="true">#</a> 3.1 新建 + 启动容器</h3><p><strong>OPTIONS 说明：</strong></p><ul><li><strong><code>--name=容器名称</code></strong>：为容器指定一个名称</li><li><strong><code>-d</code></strong>：后台运行容器并返回容器 ID，也即启动守护式容器（后台运行），比如 MySQL、Redis 等</li><li><strong><code>-i</code></strong>：以交互模式运行容器，通常与 -t 同时使用</li><li><strong><code>-t</code></strong>：为容器重新分配一个伪输入终端，通常与 -i 同时使用</li></ul><blockquote><p>使用 <strong>-it</strong> 目的是启动交互式容器（前台有伪终端，等待交互），比如我们通过 ubuntu 镜像跑容器实例时就需要使用到 <strong>-it</strong></p></blockquote><ul><li><p><strong><code>-P</code></strong>：随机端口映射，大写 P</p></li><li><p><strong><code>-p</code></strong>：指定端口映射，小写 p【一般使用这个】</p><blockquote><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-p hostPort:containerPort</td><td>端口映射 <code>-p 8080:80</code></td></tr><tr><td>-p ip:hostPort:containerPort</td><td>配置监听地址 <code>-p 10.0.0.100:8080:80</code></td></tr><tr><td>-p ip::containerPort</td><td>随机分配端口 <code>-p 10.0.0.100::80</code></td></tr><tr><td>-p hostPort:containerPort:udp</td><td>指定协议 <code>-p 8080:80:tcp</code></td></tr><tr><td>-p 80:80 -p 443:443</td><td>指定多个</td></tr></tbody></table></blockquote></li></ul><p><strong>启动交互式容器（前台命令行 ）</strong></p><figure><img src="http://img.hl1015.top/blog/image-20220309104744789.png" alt="image-20220309104744789" tabindex="0" loading="lazy"><figcaption>image-20220309104744789</figcaption></figure><p><code>docker run -it ubuntu /bin/bash</code> 命令参数说明：</p>',14),k=e("li",null,"-i：交互式操作",-1),_=e("li",null,"-t：终端",-1),x=e("li",null,"ubuntu：ubuntu 镜像",-1),I=e("li",null,"/bin/bash：放在镜像名后的是命令，我们希望有个交互式 shell，因此用的是 /bin/bash",-1),y=e("code",null,"exit",-1),D=e("strong",null,[e("code",null,"ctrl + q + p")],-1),z=o(`<h3 id="_3-2-列出当前正在运行的容器" tabindex="-1"><a class="header-anchor" href="#_3-2-列出当前正在运行的容器" aria-hidden="true">#</a> 3.2 列出当前正在运行的容器</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token function">ps</span> <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="http://img.hl1015.top/blog/image-20220309171149938.png" alt="image-20220309171149938" tabindex="0" loading="lazy"><figcaption>image-20220309171149938</figcaption></figure><p><strong>OPTIONS 说明：</strong></p>`,4),O=e("strong",null,[e("code",null,"-a")],-1),T=e("li",null,[e("strong",null,[e("code",null,"-l")]),a("：显示最近创建的容器")],-1),q=e("li",null,[e("strong",null,[e("code",null,"-n")]),a("：显示最近 n 个创建的容器")],-1),P=e("li",null,[e("strong",null,[e("code",null,"-q")]),a("：静默模式，只显示容器编号")],-1),E=e("figure",null,[e("img",{src:"http://img.hl1015.top/blog/image-20220309172114265.png",alt:"image-20220309172114265",tabindex:"0",loading:"lazy"}),e("figcaption",null,"image-20220309172114265")],-1),S=e("h3",{id:"_3-3-退出容器",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_3-3-退出容器","aria-hidden":"true"},"#"),a(" 3.3 退出容器")],-1),A=e("p",null,"两种退出方式：",-1),N=e("strong",null,"exit",-1),R=e("code",null,"exit",-1),G=e("strong",null,"ctrl + p + q",-1),C=e("code",null,"ctrl + p + q",-1),B=o(`<h3 id="_3-4-启动已停止运行的容器" tabindex="-1"><a class="header-anchor" href="#_3-4-启动已停止运行的容器" aria-hidden="true">#</a> 3.4 启动已停止运行的容器</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> start 容器ID 或 容器名
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="http://img.hl1015.top/blog/image-20220309173002921.png" alt="image-20220309173002921" tabindex="0" loading="lazy"><figcaption>image-20220309173002921</figcaption></figure><h3 id="_3-5-重启容器" tabindex="-1"><a class="header-anchor" href="#_3-5-重启容器" aria-hidden="true">#</a> 3.5 重启容器</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> restart 容器ID 或 容器名
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="http://img.hl1015.top/blog/image-20220309173108587.png" alt="image-20220309173108587" tabindex="0" loading="lazy"><figcaption>image-20220309173108587</figcaption></figure><h3 id="_3-6-停止容器" tabindex="-1"><a class="header-anchor" href="#_3-6-停止容器" aria-hidden="true">#</a> 3.6 停止容器</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> stop 容器ID 或 容器名
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="http://img.hl1015.top/blog/image-20220310085425953.png" alt="image-20220310085425953" tabindex="0" loading="lazy"><figcaption>image-20220310085425953</figcaption></figure><h3 id="_3-7-强制停止容器" tabindex="-1"><a class="header-anchor" href="#_3-7-强制停止容器" aria-hidden="true">#</a> 3.7 强制停止容器</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token function">kill</span> 容器ID 或 容器名
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="http://img.hl1015.top/blog/image-20220310085746807.png" alt="image-20220310085746807" tabindex="0" loading="lazy"><figcaption>image-20220310085746807</figcaption></figure><h3 id="_3-8-删除已停止的容器" tabindex="-1"><a class="header-anchor" href="#_3-8-删除已停止的容器" aria-hidden="true">#</a> 3.8 删除已停止的容器</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token function">rm</span> 容器ID
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="http://img.hl1015.top/blog/image-20220310090554590.png" alt="image-20220310090554590" tabindex="0" loading="lazy"><figcaption>image-20220310090554590</figcaption></figure>`,15),M=o(`<div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token function">rm</span> <span class="token parameter variable">-f</span> <span class="token variable">\${docker ps -a -q}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>或者</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">-a</span> <span class="token parameter variable">-q</span> <span class="token operator">|</span> <span class="token function">xargs</span> <span class="token function">docker</span> <span class="token function">rm</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,3),L=e("h3",{id:"_3-9-重要⭐",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_3-9-重要⭐","aria-hidden":"true"},"#"),a(" 3.9 重要⭐")],-1),V=o(`<p><strong>2、启动守护式容器（后台服务器）</strong>：在大部分场景下，我们希望 Docker 服务是在后台运行的，我们可以通过 -d 指定容器的后台运行模式</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-d</span> 容器名
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>我们使用 ubuntu:lastest 以后台模式启动一个容器 <code>docker run -d ubuntu</code>，然后我们通过 <code>docker ps -a</code> 进行查看，会发现容器已经退出</p><figure><img src="http://img.hl1015.top/blog/image-20220310092128478.png" alt="image-20220310092128478" tabindex="0" loading="lazy"><figcaption>image-20220310092128478</figcaption></figure>`,4),w=e("code",null,"service nginx start",-1),H=o(`<p>Redis 前后台启动演示（使用 <code>docker pull redis:6.0.8</code> 下载 Redis 镜像）：</p><ul><li>前台交互式启动</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-it</span> redis:6.0.8
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="http://img.hl1015.top/blog/image-20220310093643008.png" alt="image-20220310093643008" tabindex="0" loading="lazy"><figcaption>image-20220310093643008</figcaption></figure><p>此时，如果按了 <code>ctrl + c</code> 容器会自动停止退出【不推荐】</p><ul><li>后台守护式启动</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-d</span> redis:6.0.8
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="http://img.hl1015.top/blog/image-20220310094117699.png" alt="image-20220310094117699" tabindex="0" loading="lazy"><figcaption>image-20220310094117699</figcaption></figure><p><strong>3、查看容器日志</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> logs 容器ID
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="http://img.hl1015.top/blog/image-20220310094641855.png" alt="image-20220310094641855" tabindex="0" loading="lazy"><figcaption>image-20220310094641855</figcaption></figure><p><strong>4、查看容器内运行的进程</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token function">top</span> 容器ID
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="http://img.hl1015.top/blog/image-20220310094818971.png" alt="image-20220310094818971" tabindex="0" loading="lazy"><figcaption>image-20220310094818971</figcaption></figure><p><strong>5、查看容器内部细节</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> inspect 容器ID
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="http://img.hl1015.top/blog/image-20220310095525662.png" alt="image-20220310095525662" tabindex="0" loading="lazy"><figcaption>image-20220310095525662</figcaption></figure>`,17),Y=o(`<blockquote><p>两种方式：<code>docker exec</code> 或者 <code>docker attach</code></p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> 容器ID /bin/bash
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="http://img.hl1015.top/blog/image-20220310102415521.png" alt="image-20220310102415521" tabindex="0" loading="lazy"><figcaption>image-20220310102415521</figcaption></figure><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> attach 容器ID
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="http://img.hl1015.top/blog/image-20220310101839574.png" alt="image-20220310101839574" tabindex="0" loading="lazy"><figcaption>image-20220310101839574</figcaption></figure><p><code>docker exec</code> 和 <code>docker attach</code> 的区别：</p>`,6),Z=e("code",null,"exec",-1),$=e("code",null,"exit",-1),F=e("code",null,"attach",-1),Q=e("code",null,"exit",-1),U=o(`<p>因此，建议大家使用 <code>docker exec</code>，因为退出容器终端，不会导致容器的停止</p><p>进入之前的 Redis 容器实例：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> 容器ID /bin/bash
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="http://img.hl1015.top/blog/image-20220310103020095.png" alt="image-20220310103020095" tabindex="0" loading="lazy"><figcaption>image-20220310103020095</figcaption></figure><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> 容器ID redis-cli
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="http://img.hl1015.top/blog/image-20220310103128823.png" alt="image-20220310103128823" tabindex="0" loading="lazy"><figcaption>image-20220310103128823</figcaption></figure>`,6),W=o(`<p><strong>7、从容器内拷贝文件到主机上</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token function">cp</span> 容器ID:容器内路径 目标主机路径
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="http://img.hl1015.top/blog/image-20220310105533041.png" alt="image-20220310105533041" tabindex="0" loading="lazy"><figcaption>image-20220310105533041</figcaption></figure><p><strong>8、导入和导出容器</strong></p><ul><li><code>export</code> 导出容器的内容留作为一个 tar 归档 文件</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token builtin class-name">export</span> 容器ID <span class="token operator">&gt;</span> 文件名.tar
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="http://img.hl1015.top/blog/image-20220310110559779.png" alt="image-20220310110559779" tabindex="0" loading="lazy"><figcaption>image-20220310110559779</figcaption></figure><ul><li><code>import</code> 从 tar 包中的内容创建一个新的文件系统再导入为镜像</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">cat</span> 文件名.tar <span class="token operator">|</span> <span class="token function">docker</span> <span class="token function">import</span> - 镜像用户/镜像名:镜像版本号
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="http://img.hl1015.top/blog/image-20220310111127020.png" alt="image-20220310111127020" tabindex="0" loading="lazy"><figcaption>image-20220310111127020</figcaption></figure><h2 id="_4-总结" tabindex="-1"><a class="header-anchor" href="#_4-总结" aria-hidden="true">#</a> 4. 总结</h2><figure><img src="http://img.hl1015.top/blog/image-20220310111326877.png" alt="image-20220310111326877" tabindex="0" loading="lazy"><figcaption>image-20220310111326877</figcaption></figure><ul><li><strong><code>attach</code></strong>：当前 shell 下 attach 连接指定运行镜像</li><li><strong><code>build⭐</code></strong>：通过 Dockerfile 定制镜像</li><li><strong><code>commit</code></strong>：提交当前容器为新的镜像</li><li><strong><code>cp</code></strong>：从容器中拷贝指定文件或者目录到宿主机中</li><li><strong><code>create</code></strong>：创建一个新的容器，同 run，但不启动容器</li><li><strong><code>diff</code></strong>：查看 docker 容器变化</li><li><strong><code>events</code></strong>：从 docker 服务获取容器实时事件</li><li><strong><code>exec⭐</code></strong>：在已存在的容器上运行命令</li><li><strong><code>export</code></strong>：导出容器的内容流作为一个 tar 归档文件[对应 import]</li><li><strong><code>history</code></strong>：展示一个镜像形成历史</li><li><strong><code>images⭐</code></strong>：列出系统当前镜像</li><li><strong><code>import</code></strong>：从 tar 包中的内容创建一个新的文件系统镜像[对应 export]</li><li><strong><code>info</code></strong>：显示系统相关信息</li><li><strong><code>inspect</code></strong>：查看容器详细信息</li><li><strong><code>kill</code></strong>：kill 指定 docker 容器</li><li><strong><code>load</code></strong>：从一个 tar 包中加载一个镜像[对应 save]</li><li><strong><code>login</code></strong>：注册或者登录一个 docker 源服务器</li><li><strong><code>logout</code></strong>：从当前 Docker Registry 退出</li><li><strong><code>logs</code></strong>：输出当前容器日志信息</li><li><strong><code>port</code></strong>：查看映射端口对应的容器内部源端口</li><li><strong><code>pause</code></strong>：暂停容器</li><li><strong><code>ps⭐</code></strong>：列出容器列表</li><li><strong><code>pull⭐</code></strong>：从 docker 镜像源服务器拉取指定镜像或者库镜像</li><li><strong><code>push</code></strong>：推送指定镜像或者库镜像至 docker 源服务器</li><li><strong><code>restart⭐</code></strong>：重启运行的容器</li><li><strong><code>rm</code></strong>：移除一个或者多个容器</li><li><strong><code>rmi</code></strong>：移除一个或者多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续 - f 强制删除]</li><li><strong><code>run⭐</code></strong>：创建一个新的容器并运行</li><li><strong><code>save</code></strong>：保存一个镜像为一个 tar 包[对应 load]</li><li><strong><code>start⭐</code></strong>：启动容器</li><li><strong><code>stop⭐</code></strong>：停止容器</li><li><strong><code>tag</code></strong>：给源中镜像打标签</li><li><strong><code>top</code></strong>：查看容器中运行的进程信息</li><li><strong><code>unpause</code></strong>：取消暂停容器</li><li><strong><code>version</code></strong>：查看 docker 版本号</li><li><strong><code>wait</code></strong>：截取容器停止时的退出状态值</li></ul>`,13);function j(J,K){const t=l("ExternalLinkIcon"),i=l("font");return c(),r("div",null,[u,e("blockquote",null,[e("p",null,[a("Docker Hub 官网地址："),e("a",p,[a("https://hub.docker.com"),n(t)])])]),h,e("ul",null,[e("li",null,[m,e("ul",null,[e("li",null,[a("删除全部【"),n(i,{color:"red"},{default:s(()=>[a("慎用，工作时千万别用")]),_:1}),a("】")])]),b]),f]),v,e("ul",null,[k,_,x,I,e("li",null,[a("要退出终端，直接输入 "),y,a("，会导致容器停止，不推荐 --- "),n(i,{color:"blue"},{default:s(()=>[a("建议使用按键 "),D,a(" 进行退出")]),_:1})])]),z,e("ul",null,[e("li",null,[O,a("：列出当前所有"),n(i,{color:"red"},{default:s(()=>[a("正在运行的 + 历史上运行过的")]),_:1}),a("容器")]),T,q,P]),E,S,A,e("ul",null,[e("li",null,[N,a("：run 进去容器（交互模式），输入 "),R,a(" 退出，"),n(i,{color:"red"},{default:s(()=>[a("容器会停止")]),_:1})]),e("li",null,[G,a("：run 进去容器（交互模式），通过按键 "),C,a(" 退出，"),n(i,{color:"red"},{default:s(()=>[a("容器不会停止")]),_:1})])]),B,e("blockquote",null,[e("p",null,[a("一次性删除多个容器（"),n(i,{color:"red"},{default:s(()=>[a("慎用，工作中尽量杜绝使用")]),_:1}),a("）")]),M]),L,e("p",null,[e("strong",null,[a("1、"),n(i,{color:"red"},{default:s(()=>[a("有镜像才能创建容器，这是根本前提")]),_:1})])]),V,e("p",null,[a("这里很重要地要说明的一点："),n(i,{color:"red"},{default:s(()=>[a("Docker 容器后台运行，就必须有一个前台进程")]),_:1})]),e("p",null,[a("容器运行的命令如果不是那些"),n(i,{color:"red"},{default:s(()=>[a("一直挂起的命令（比如运行 top，tail）")]),_:1}),a("，就是会自动退出的，这个是 Docker 机制的问题，比如你的 Web 容器，我们以 Nginx 为例，正常情况下，我们配置启动服务只需要启动相应的 Service 即可，例如 "),w,a("，但是，这样做，Nginx 为后台进程模式运行，就导致 Docker 前台没有运行的应用，这样的容器后台启动后，会立即自杀，因为它觉得没事可做了，所以，最佳的解决方案是："),n(i,{color:"red"},{default:s(()=>[a("将你要运行的程序以前台进程的形式运行，常见的就是命令行模式，表示我还有交互操作，别中断，O(∩_∩)O哈哈")]),_:1})]),H,e("p",null,[e("strong",null,[a("6、"),n(i,{color:"red"},{default:s(()=>[a("进入正在运行的容器并以命令行交互")]),_:1})])]),Y,e("ul",null,[e("li",null,[Z,a(" 是在容器中打开新的终端，并且可以启动新的进程，用 "),$,a(" 退出，"),n(i,{color:"blue"},{default:s(()=>[a("不会导致容器的停止")]),_:1})]),e("li",null,[F,a(" 直接进入容器启动命令的终端，不会启动新的进程，用 "),Q,a(" 退出，"),n(i,{color:"blue"},{default:s(()=>[a("会导致容器的停止")]),_:1})])]),U,n(i,{color:"blue"},{default:s(()=>[a("一般我们使用 -d 后台启动程序，然后再用 exec 进入对应的容器实例")]),_:1}),W])}const ee=d(g,[["render",j],["__file","docker-basic-3.html.vue"]]);export{ee as default};
