import{_ as i,Z as e,$ as a,a5 as l}from"./framework-1fb77053.js";const r={},n=l('<h2 id="_1-aof-append-only-file" tabindex="-1"><a class="header-anchor" href="#_1-aof-append-only-file" aria-hidden="true">#</a> 1. AOF（Append Only File）</h2><h3 id="_1-1-aof-是什么" tabindex="-1"><a class="header-anchor" href="#_1-1-aof-是什么" aria-hidden="true">#</a> 1.1 AOF 是什么</h3><p><span style="color:red;">以<strong>日志</strong>的形式来记录每个写操作（增量保存）</span>，将 Redis 执行过的所有写指令记录下来（<span style="color:red;"><strong>读操作不会记录</strong></span>），<span style="color:red;"><strong>只许追加文件但不可以改写文件</strong></span>，Redis 启动之初会读取该文件重新构建数据，换言之，Redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p><h3 id="_1-2-aof-持久化流程" tabindex="-1"><a class="header-anchor" href="#_1-2-aof-持久化流程" aria-hidden="true">#</a> 1.2 AOF 持久化流程</h3><p>（1）客户端的请求写命令会被 append 追加到 AOF 缓冲区内</p><p>（2）AOF 缓冲区根据 AOF 持久化策略 [always, everysec, no] 将操作 sync 同步到磁盘的 AOF 文件中</p><p>（3）AOF 文件大小超过重写策略或手动重写时，会对 AOF 文件 rewrite 重写，压缩 AOF 文件容量</p><p>（4）Redis 服务重启时，会重新 load 加载 AOF 文件中的写操作达到数据恢复的目的</p><figure><img src="http://img.hl1015.top/blog/image-20211122165808404.png" alt="image-20211122165808404" tabindex="0" loading="lazy"><figcaption>image-20211122165808404</figcaption></figure><h3 id="_1-3-aof-默认不开启" tabindex="-1"><a class="header-anchor" href="#_1-3-aof-默认不开启" aria-hidden="true">#</a> 1.3 AOF 默认不开启</h3><p>可以在 redis.conf 中配置文件名称，默认为 <span style="color:red;">appendobly.aof</span></p><p>AOF 文件的保存路径，同 RDB 的路径一致</p><h3 id="_1-4-aof-和-rdb-同时开启-redis-听谁的" tabindex="-1"><a class="header-anchor" href="#_1-4-aof-和-rdb-同时开启-redis-听谁的" aria-hidden="true">#</a> 1.4 AOF 和 RDB 同时开启，redis 听谁的？</h3><p>AOF 和 RDB 同时开启，系统默认取 AOF 的数据（数据不会存在丢失）</p><h3 id="_1-5-aof-启动-修复-恢复" tabindex="-1"><a class="header-anchor" href="#_1-5-aof-启动-修复-恢复" aria-hidden="true">#</a> 1.5 AOF 启动/修复/恢复</h3><ul><li>AOF 的备份机制和性能虽然和 RDB 不同，但是备份和恢复的操作同 RDB 一样，都是拷贝备份文件，需要恢复时再拷贝到 Redis 的工作目录下，启动系统即加载。</li><li>正常恢复 <ul><li>修改默认的 appendonly no，改为 yes</li><li>将有数据的 aof 文件复制一份保存到对应目录（查看目录：config get dir）</li><li>恢复：重启 redis 然后重新加载</li></ul></li><li>异常恢复 <ul><li>修改默认的 appendonly no，改为 yes</li><li>如遇到 <span style="color:red;"><strong>AOF 文件损坏</strong></span>，通过 /usr/local/bin/<span style="color:red;">redis-check-aof --fix appendonly.aof</span> 进行恢复</li><li>备份被写坏的 AOF 文件</li><li>恢复：重启 redis，然后重新加载</li></ul></li></ul><h3 id="_1-6-aof-同步频率设置" tabindex="-1"><a class="header-anchor" href="#_1-6-aof-同步频率设置" aria-hidden="true">#</a> 1.6 AOF 同步频率设置</h3><ul><li><p><strong>appendfsync always</strong>：始终同步，每次 Redistribution的写操作都会立即记入日志</p></li><li><p><strong>appendfsync everysec</strong>：每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失</p></li><li><p><strong>appendfsync no</strong>：redis 不主动进行同步，把<span style="color:red;">同步时机交给操作系统</span></p></li></ul><h3 id="_1-7-rewrite-压缩" tabindex="-1"><a class="header-anchor" href="#_1-7-rewrite-压缩" aria-hidden="true">#</a> 1.7 Rewrite 压缩</h3><p><strong>（1）是什么</strong></p><p>AOF 采用文件追加方式，文件会越来越大，为避免出现此种情况，新增了重写机制，当 AOF 文件的大小超过所设定的阈值时，Redis 就会启动 AOF 文件的内容压缩，只保留可以恢复数据的最小指令集，可以使用命令 bgrewriteaof</p><p><strong>（2）重写原理【如何重写】</strong></p><p>AOF 文件持续增长而过大时，会 fork 出一条新进程来将文件重写（也是先写临时文件最后再 rename），<span style="color:red;">redis 4.0 版本后的重写，实质上就是把 rdb 的快照，以二进制的形式附在新的 aof 头部，作为已有的历史数据，替换掉原来的流水账操作</span>。</p><p>no-appendfsync-on-rewrite：</p><ul><li>如果 no-appendfsync-on-rewrite=yes，不写入 aof 文件只写入缓存，用户请求不会阻塞，但是这段时间如果宕机会丢失这段时间的缓存数据（降低数据安全性，提高性能）</li><li>如果 no-appendfsync-on-rewrite=no，还是会把数据往磁盘里刷，但是遇到重写操作，可能会发生阻塞（数据安全，但是性能降低）</li></ul><p>触发机制，何时重写？</p><ul><li>Redis 会记录上次重写时的 AOF 文件大小，默认配置是当 AOF 文件大小是上次 rewrite 后大小的一倍且文件大于 64 M 时触发</li><li><span style="color:blue;">重写虽然可以节约大量磁盘空间，减少恢复时间，但是每次重写还是有一定的负担的，因此设定 Redis 要满足一定条件才会进行重写</span><ul><li>auto-aof-rewrite-percetage：设置重写的基准值，文件达到 100% 时开始重写（文件是原来重写后文件的 2 倍时触发）</li><li>auto-aof-rewrite-min-size：设置重写的基准值，最小文件 64 MB，达到这个值开始重写 <ul><li>例如：文件达到 70 MB 开始重写，降到 50 MB，下次什么时候开始重写？100 MB</li><li>系统载入时或者上次重写完毕时，Redis 会记录此时 AOF 大小，设为 base_size，如果 Redis 的 <span style="color:red;">AOF 当前大小 &gt;= base_size + base_size * 100%（默认）且当前大小 &gt;= 64 MB（默认）</span>的情况下，Redis 会对 AOF 进行重写</li></ul></li></ul></li></ul><p><strong>（3）重写流程</strong></p><ul><li>bgrewriteaof 触发重写，判断是否当前有 bgsave 或 bgrewriteaof 在运行，如果有，则等待该命令结束后再继续执行</li><li>主进程 fork 出子进程执行重写操作，保证主进程不会阻塞</li><li>子进程遍历 redis 内存中数据到临时文件，客户端的写请求同时写入 aof_buf 缓冲区和 aof_rewrite_buf 重写缓冲区保证原 AOF 文件完整以及新 AOF 文件生成期间的新的数据修改动作不会丢失</li><li>①子进程写完新的 AOF 文件后，向主进程发信号，父进程更新统计信息；②主进程把 aof_rewrite_buf 中的数据写入到新的 AOF 文件</li><li>使用新的 AOF 文件覆盖旧的 AOF 文件，完成 AOF 重写</li></ul><figure><img src="http://img.hl1015.top/blog/image-20211122230208026.png" alt="image-20211122230208026" tabindex="0" loading="lazy"><figcaption>image-20211122230208026</figcaption></figure><h3 id="_1-8-优势" tabindex="-1"><a class="header-anchor" href="#_1-8-优势" aria-hidden="true">#</a> 1.8 优势</h3><figure><img src="http://img.hl1015.top/blog/image-20211123090449641.png" alt="image-20211123090449641" tabindex="0" loading="lazy"><figcaption>image-20211123090449641</figcaption></figure><ul><li>备份机制更稳健，丢失数据概率更低</li><li>可读的日志文本，通过操作 AOF 稳健，可以处理误操作</li></ul><h3 id="_1-9-劣势" tabindex="-1"><a class="header-anchor" href="#_1-9-劣势" aria-hidden="true">#</a> 1.9 劣势</h3><ul><li>比起 RDB 占用更多的磁盘空间</li><li>恢复备份速度要慢</li><li>每次读写都同步的话，有一定的性能压力</li><li>存在个别 bug，造成不能恢复</li></ul><h3 id="_1-10-小总结" tabindex="-1"><a class="header-anchor" href="#_1-10-小总结" aria-hidden="true">#</a> 1.10 小总结</h3><ul><li>AOF 文件是一个只进行追加的日志文件</li><li>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写</li><li>AOF 文件有序地保存了对数据库执行的所有写入操作，这些写入操作以 Redis 协议的格式保存，因此 AOF 文件的内容非常容易被人读懂，对文件进行分析也很轻松</li><li>对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积</li><li>根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB</li></ul><h2 id="_2-总结-which-one" tabindex="-1"><a class="header-anchor" href="#_2-总结-which-one" aria-hidden="true">#</a> 2. 总结（which one）</h2><h3 id="_2-1-用哪个好" tabindex="-1"><a class="header-anchor" href="#_2-1-用哪个好" aria-hidden="true">#</a> 2.1 用哪个好</h3><p>官方推荐两个都启用。</p><ul><li>如果对数据不敏感，可以单独用 RDB</li><li>不建议单独用 AOF，因为可能会出现 bug</li><li>如果只是做纯内存缓存，可以都不用</li></ul><h3 id="_2-2-官网建议" tabindex="-1"><a class="header-anchor" href="#_2-2-官网建议" aria-hidden="true">#</a> 2.2 官网建议</h3><figure><img src="http://img.hl1015.top/blog/image-20211123091822859.png" alt="image-20211123091822859" tabindex="0" loading="lazy"><figcaption>image-20211123091822859</figcaption></figure><figure><img src="http://img.hl1015.top/blog/image-20211123095519154.png" alt="image-20211123095519154" tabindex="0" loading="lazy"><figcaption>image-20211123095519154</figcaption></figure><ul><li>RDB 持久化方式能够在指定的时间间隔对你的数据进行快照存储</li><li>AOF 持久化方式记录每次对服务器的写操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF 命令以 Redis 协议追加保存每次写的操作到文件末尾，Redis 还能对 AOF 文件进行后台重写，使得 AOF 文件的体积不至于过大</li><li>只做缓存：如果你只希望你的数据在服务器运行的时候存在，你也可以不适用任何持久化方式</li><li>同时开启两种持久化方式，在这种情况下，当 Redis 重启的时候会优先载入 AOF 文件来恢复原始的数据，因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集要完整</li><li>RDB 的数据不实时，同时使用两者时服务器重启也只会找 AOF 文件，那要不要只使用 AOF？建议不要，因为 RDB 更适合用于备份数据库（AOF 在不断变化不好备份），快速重启，而且不会有 AOF 可能潜在的 bug，留着作为一个万一的手段</li><li>性能建议 <ul><li>因为 RDB 文件只用作后备用途，建议只在 <span style="color:red;">Slave 上持久化 RDB 文件</span>，而且只要 15 分钟备份一次就够了，只保留 save 900 1 这条规则。</li><li>如果使用 AOF，好处是在最恶劣的情况下也只会丢失不超过两秒数据，启动脚本较简单，只需 load 自己的 AOF 文件就可以了 <ul><li>代价：一是带来了持续的 IO，二是 AOF rewrite 的最后将 rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的</li><li>只要硬盘许可，应该尽量减少 AOF rewrite 的频率，AOF 重写的基础大小默认值 64 M 大小了，可以设到 5 G 以上</li><li>默认超过原大小 100% 大小时重写可以改到适当的数值</li></ul></li></ul></li></ul>',45),o=[n];function s(d,t){return e(),a("div",null,o)}const h=i(r,[["render",s],["__file","redis-13.html.vue"]]);export{h as default};
