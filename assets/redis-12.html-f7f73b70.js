import{_ as r,E as s,Z as d,$ as n,a0 as a,a1 as e,a3 as t,a5 as l}from"./framework-1fb77053.js";const o={},h=a("h2",{id:"_1-总体介绍",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#_1-总体介绍","aria-hidden":"true"},"#"),e(" 1. 总体介绍")],-1),g={href:"https://www.redis.io",target:"_blank",rel:"noopener noreferrer"},p=l(`<figure><img src="http://img.hl1015.top/blog/image-20211122131838716.png" alt="image-20211122131838716" tabindex="0" loading="lazy"><figcaption>image-20211122131838716</figcaption></figure><figure><img src="http://img.hl1015.top/blog/image-20211122133004091.png" alt="image-20211122133004091" tabindex="0" loading="lazy"><figcaption>image-20211122133004091</figcaption></figure><p>Redis 提供了 2 种不同形式的持久化方式</p><ul><li>RDB（Redis DataBase）</li><li>AOF（Append Of File）</li></ul><h2 id="_2-rdb-redis-database" tabindex="-1"><a class="header-anchor" href="#_2-rdb-redis-database" aria-hidden="true">#</a> 2. RDB（Redis DataBase）</h2><h3 id="_2-1-官网介绍" tabindex="-1"><a class="header-anchor" href="#_2-1-官网介绍" aria-hidden="true">#</a> 2.1 官网介绍</h3><figure><img src="http://img.hl1015.top/blog/image-20211122132057544.png" alt="image-20211122132057544" tabindex="0" loading="lazy"><figcaption>image-20211122132057544</figcaption></figure><figure><img src="http://img.hl1015.top/blog/image-20211122133024368.png" alt="image-20211122133024368" tabindex="0" loading="lazy"><figcaption>image-20211122133024368</figcaption></figure><h3 id="_2-2-rdb-是什么" tabindex="-1"><a class="header-anchor" href="#_2-2-rdb-是什么" aria-hidden="true">#</a> 2.2 RDB 是什么</h3><p>在<span style="color:red;">指定的时间间隔</span>内将内存中的数据集<span style="color:red;">快照</span>写入磁盘，也就是行话讲的 Snapshot 快照，它恢复时是将快照文件直接读到内存里。</p><h3 id="_2-3-备份是如何执行的" tabindex="-1"><a class="header-anchor" href="#_2-3-备份是如何执行的" aria-hidden="true">#</a> 2.3 备份是如何执行的</h3><p>Redis 会单独创建（fork）一个子进程来进行持久化，会<span style="color:red;">先将数据写入到一个临时文件</span>中，待持久化过程都结束了，再用这个<span style="color:red;">临时文件替换上次持久化好的文件</span>。整个过程中，主进程是不进行任何 IO 操作的，这就确保了极高的性能，如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那 RDB 方式要比 AOF 方式更加的高效。<span style="color:red;"><strong>RDB 的缺点是最后一次持久化后的数据可能丢失</strong></span>。</p><h3 id="_2-4-fork" tabindex="-1"><a class="header-anchor" href="#_2-4-fork" aria-hidden="true">#</a> 2.4 Fork</h3><ul><li>Fork 的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值和原进程一致，但是是一个全新的进程，并作为原进程的子进程。</li><li>在 Linux 程序中，fork() 会产生一个和父进程完全相同的子进程，但子进程在此后多会被 exec 系统调用，出于效率考虑，Linux 中引入了 &quot;<span style="color:red;"><strong>写时复制技术</strong></span>&quot;</li><li><strong>一般情况父进程和子进程会共用同一段物理内存</strong>，只有进程空间的各段内容要发生变化时，才会将父进程的内容复制一份给子进程。</li></ul><h3 id="_2-5-rdb-持久化流程" tabindex="-1"><a class="header-anchor" href="#_2-5-rdb-持久化流程" aria-hidden="true">#</a> 2.5 RDB 持久化流程</h3><figure><img src="http://img.hl1015.top/blog/image-20211122135032453.png" alt="image-20211122135032453" tabindex="0" loading="lazy"><figcaption>image-20211122135032453</figcaption></figure><h3 id="_2-6-dump-rdb-文件" tabindex="-1"><a class="header-anchor" href="#_2-6-dump-rdb-文件" aria-hidden="true">#</a> 2.6 dump.rdb 文件</h3><p>在 redis.conf 中配置文件名称，默认为 dump.rdb</p><figure><img src="http://img.hl1015.top/blog/image-20211122135510277.png" alt="image-20211122135510277" tabindex="0" loading="lazy"><figcaption>image-20211122135510277</figcaption></figure><h3 id="_2-7-配置位置" tabindex="-1"><a class="header-anchor" href="#_2-7-配置位置" aria-hidden="true">#</a> 2.7 配置位置</h3><p>rdb 文件的保存路径，也可以修改，默认为 Redis 启动时命令行所在的目录下</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">dir</span> /myredis/
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="http://img.hl1015.top/blog/image-20211122135658693.png" alt="image-20211122135658693" tabindex="0" loading="lazy"><figcaption>image-20211122135658693</figcaption></figure><h3 id="_2-8-如何触发-rdb-快照-保持策略" tabindex="-1"><a class="header-anchor" href="#_2-8-如何触发-rdb-快照-保持策略" aria-hidden="true">#</a> 2.8 如何触发 RDB 快照，保持策略</h3><h4 id="_2-8-1-配置文件中默认的快照配置" tabindex="-1"><a class="header-anchor" href="#_2-8-1-配置文件中默认的快照配置" aria-hidden="true">#</a> 2.8.1 配置文件中默认的快照配置</h4><figure><img src="http://img.hl1015.top/blog/image-20211122140104563.png" alt="image-20211122140104563" tabindex="0" loading="lazy"><figcaption>image-20211122140104563</figcaption></figure><h4 id="_2-8-2-命令-save-vs-bgsave" tabindex="-1"><a class="header-anchor" href="#_2-8-2-命令-save-vs-bgsave" aria-hidden="true">#</a> 2.8.2 命令 save VS bgsave</h4><ul><li><strong>save</strong>：save 时只管保存，其它不管，全部阻塞，手动保存，不建议</li><li><span style="color:red;"><strong>bgsave</strong>：Redis 会在后台异步进行快照操作，快照同时还可以响应客户端请求</span></li></ul><blockquote><p>可以通过 <strong>lastsave</strong> 命令获取最后一次成功执行快照的时间</p></blockquote><h4 id="_2-8-3-flushall-命令" tabindex="-1"><a class="header-anchor" href="#_2-8-3-flushall-命令" aria-hidden="true">#</a> 2.8.3 flushall 命令</h4><p>执行 flushall 命令，也会产生 dump.rdb 文件，但里面是空的，无意义</p><h4 id="_2-8-4-save" tabindex="-1"><a class="header-anchor" href="#_2-8-4-save" aria-hidden="true">#</a> 2.8.4 save</h4><p>格式：<code>save 秒钟 写操作次数</code></p><p>RDB 是整个内存的压缩过的 Snapshot，RDB 的数据结构，可以配置复合的快照触发条件，<span style="color:red;"><strong>默认是 1 分钟内改了 1 万次，或 5 分钟内改了 100 次，或 60 分钟内改了 1 次</strong></span></p><p><span style="color:red;">禁用：不设置 save 指令，或者给 save 传入空字符串</span></p><h4 id="_2-8-5-stop-writes-on-bgsave-error" tabindex="-1"><a class="header-anchor" href="#_2-8-5-stop-writes-on-bgsave-error" aria-hidden="true">#</a> 2.8.5 stop-writes-on-bgsave-error</h4><figure><img src="http://img.hl1015.top/blog/image-20211122142526415.png" alt="image-20211122142526415" tabindex="0" loading="lazy"><figcaption>image-20211122142526415</figcaption></figure><p>当 Redis 无法写入磁盘的话，直接关掉 Redis 的写操作，推荐 yes</p><h4 id="_2-8-6-rdbcompression-压缩文件" tabindex="-1"><a class="header-anchor" href="#_2-8-6-rdbcompression-压缩文件" aria-hidden="true">#</a> 2.8.6 rdbcompression 压缩文件</h4><figure><img src="http://img.hl1015.top/blog/image-20211122142621430.png" alt="image-20211122142621430" tabindex="0" loading="lazy"><figcaption>image-20211122142621430</figcaption></figure><p>对于存储到磁盘中的快照，可以设置是否进行压缩存储，如果是的话，Redis 会采用 <span style="color:red;">LZF 算法</span> 进行压缩</p><p>如果你不想消耗 CPU 来进行压缩的话，可以设置为关闭此功能，推荐 yes</p><h4 id="_2-8-7-rdbchecksum-检查完整性" tabindex="-1"><a class="header-anchor" href="#_2-8-7-rdbchecksum-检查完整性" aria-hidden="true">#</a> 2.8.7 rdbchecksum 检查完整性</h4><figure><img src="http://img.hl1015.top/blog/image-20211122143103765.png" alt="image-20211122143103765" tabindex="0" loading="lazy"><figcaption>image-20211122143103765</figcaption></figure><p>在存储快照后，还可以让 Redis 使用 CRC64 算法来进行数据校验，但是这样做会增加大约 10% 的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能，推荐 yes</p><h4 id="_2-8-8-rdb-的备份与恢复" tabindex="-1"><a class="header-anchor" href="#_2-8-8-rdb-的备份与恢复" aria-hidden="true">#</a> 2.8.8 rdb 的备份与恢复</h4><p>备份：</p><ul><li>先通过 <code>config get dir</code> 查询 rdb 文件的目录</li><li>将 *.rdb 的文件拷贝到别的地方</li></ul><p>恢复：</p><ul><li>关闭 Redis</li><li>先把备份的文件拷贝到工作目录下 cp dump2.rdb dump.rdb</li><li>启动 Redis，备份数据会直接加载</li></ul><h3 id="_2-9-优势" tabindex="-1"><a class="header-anchor" href="#_2-9-优势" aria-hidden="true">#</a> 2.9 优势</h3><ul><li>适合大规模的数据恢复</li><li>对数据完整性和一致性要求不高更适合使用</li><li>节省磁盘空间</li><li>恢复速度快</li></ul><figure><img src="http://img.hl1015.top/blog/image-20211122144110172.png" alt="image-20211122144110172" tabindex="0" loading="lazy"><figcaption>image-20211122144110172</figcaption></figure><h3 id="_2-10-劣势" tabindex="-1"><a class="header-anchor" href="#_2-10-劣势" aria-hidden="true">#</a> 2.10 劣势</h3><ul><li>Fork 的时候，内存中的数据被克隆了一份，大致 2 倍的膨胀性需要考虑</li><li>虽然 Redis 在 fork 时使用了<span style="color:red;"><strong>写时拷贝技术</strong></span>，但是如果数据庞大时还是比较消耗性能</li><li>在备份周期在一定间隔时间做一次备份，所以如果 Redis 意外 down 掉的话，就会丢失最后一次快照后的所有修改</li></ul><h3 id="_2-11-如何停止" tabindex="-1"><a class="header-anchor" href="#_2-11-如何停止" aria-hidden="true">#</a> 2.11 如何停止</h3><p>动态停止 RDB：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>redis-cli config <span class="token builtin class-name">set</span> save <span class="token string">&quot;&quot;</span> <span class="token comment"># save 后给空值，表示禁用保存策略</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_2-12-小总结" tabindex="-1"><a class="header-anchor" href="#_2-12-小总结" aria-hidden="true">#</a> 2.12 小总结</h3><ul><li>RDB 是一个非常紧凑的文件</li><li>RDB 在保存 RDB 文件时父进程唯一需要做的就是 fork 出一个子进程，接下来的工作全部由子进程来做，父进程不需要再做其他 IO 操作，所以 RDB 持久化方式可以最大化 Redis 的性能</li><li>与 AOF 相比，在恢复大的数据集的时候，RDB 方式会更快一些</li><li>数据丢失风险大</li><li>RDB 需要经常 fork 子进程来保存数据集到硬盘上，当数据集比较大的时候，fork 的过程是非常耗时的，可能会导致 Redis 在一些毫秒级不能响应客户端请求</li></ul>`,60);function c(u,b){const i=s("ExternalLinkIcon");return d(),n("div",null,[h,a("p",null,[e("官网介绍："),a("a",g,[e("https://www.redis.io"),t(i)])]),p])}const m=r(o,[["render",c],["__file","redis-12.html.vue"]]);export{m as default};
